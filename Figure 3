```{r Data}
targets <- read_tsv("studydesignC9.txt") #object is called 'targets' to refer to dataset, file must be in working directory
```

```{r step 1 - TxImport}
path <- file.path(targets$name, "abundance.tsv") # set file paths to your mapped Kallisto data
all(file.exists(path)) 
Tx <- transcripts(EnsDb.Mmusculus.v79, columns=c("tx_id", "gene_name"))
Tx <- as_tibble(Tx) 
Tx <- dplyr::rename(Tx, target_id = tx_id) #kallisto file will be looking for target_id
Tx <- dplyr::select(Tx, "target_id", "gene_name") #select columns of interest, disregard other columns
Txi_gene <- tximport(path, #we defined this path in earlier code
                     type = "kallisto", #type of file
                     tx2gene = Tx, #map of transcripts to genes
                     txOut = FALSE, #How does the result change if this =FALSE vs =TRUE, TRUE = transcript level data, FALSE = gene level data
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = TRUE) #ignores .1 in transcript data file, can identify transcript code
```

```{r step2 - dataWrangling}
# recall that your abundance data are TPM, while the counts are read counts mapping to each gene or transcript
myTPM <- Txi_gene$abundance #this provides the TPM numbers
myCounts <- Txi_gene$counts
colSums(myTPM) #total TPM, should be close to 1 million for genes, should be exactly 1 million for transcripts
colSums(myCounts) #total number of reads mapping to reference for each sample
sampleLabels <- targets$name

myDGEList <- DGEList(myCounts)
#save(myDGEList, file = "myDGEList")
#load(file = "myDGEList") #Saved DGEList objects can be easily shared and loaded into an R environment
cpm <- cpm(myDGEList) # use the 'cpm' function from EdgeR to get counts per million
colSums(cpm)
log2.cpm <- cpm(myDGEList, log=TRUE)
log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID") # 'coerce' your data matrix to a dataframe so that you can use tidyverse tools on it
colnames(log2.cpm.df) <- c("geneID", sampleLabels) #override first column with label and then add sample names

# use the tidy package to 'pivot' your dataframe (from wide to long) this turns each variable into a column
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, # dataframe to be pivoted
                                  cols = PBS_E9_C_M_A9_C1:BRA_E9_C_F_A36_C8, # column names to be stored as a SINGLE variable
                                  names_to = "name", # name of that new variable (column)
                                  values_to = "expression") # name of new variable (column) storing all the values (data)
p1 <- ggplot(log2.cpm.df.pivot) +
  aes(x=name, y=expression, fill=name) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

# Filter your data
#first, take a look at how many genes or transcripts have no read counts at all
table(rowSums(myDGEList$counts==0)==56)
# breaking down the line above is a little tricky.  Let's try:
# 1st - 'myDGEList$counts==0' returns a new 'logical matrix' where each observation (gene) is evaluated (TRUE/FALSE) for each variable (sample) as to whether it has zero counts
# 2nd - passing this logical matrix to 'rowsums' allows you to sum the total number of times an observation was 'TRUE' across all samples
# 3rd - adding the '==192' is a simple way of asking how many of the rowsums equaled 192. In other words, how many genes had 0 counts (TRUE) for all (192) samples in our dataset
# 4th - passing all this to the 'table' function just provides a handy way to summarize the large logical produced in the previous step

# now set some cut-off to get rid of genes/transcripts with low counts
# again using rowSums to tally up the 'TRUE' results of a simple evaluation
# how many genes had more than 1 CPM (TRUE) in at least 3 samples

# The line below is important! This is where the filtering starts
# Be sure to adjust this cutoff for the number of samples in the smallest group of comparison.
keepers <- rowSums(cpm>1)>=17 
myDGEList.filtered <- myDGEList[keepers,]
dim(myDGEList.filtered)
log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE) #repeat code above but with filtered data only
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID")
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, # dataframe to be pivoted
                                           cols = PBS_E9_C_M_A9_C1:BRA_E9_C_F_A36_C8, # column names to be stored as a SINGLE variable
                                           names_to = "name", # name of that new variable (column)
                                           values_to = "expression") # name of new variable (column) storing all the values (data)


p2 <- ggplot(log2.cpm.filtered.df.pivot) +
  aes(x=name, y=expression, fill=name) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "name",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

# Normalize your data
myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")

# use the 'cpm' function from EdgeR to get counts per million from your normalized data
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE)
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID")
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
# pivot this NORMALIZED data, just as you did earlier
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, # dataframe to be pivoted
                                                cols = PBS_E9_C_M_A9_C1:BRA_E9_C_F_A36_C8, # column names to be stored as a SINGLE variable
                                                names_to = "name", # name of that new variable (column)
                                                values_to = "expression") # name of new variable (column) storing all the values (data)


p3 <- ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=name, y=expression, fill=name) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "name",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()
# coord_flip()
# what if we wanted to put all three violin plots together?
# go back and assign each plot to a variable (rather than printing to the plots viewer)
# here we assigned the last 3 plots to p1, p2 and p3
# we'll use the 'plot_grid' function from the cowplot package to put these together in a figure
plot_grid(p1, p2, p3, labels = c('A', 'B', 'C'), label_size = 12, nrow = 1)
```
#Filtering was carried out to remove lowly expressed genes. Genes with less than 1 count per million (CPM) in at least 5 or more samples filtered out.  This reduced the number of genes from `r nrow(myDGEList)` to `r nrow(myDGEList.filtered)`. 











